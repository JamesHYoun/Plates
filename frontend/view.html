<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5.js Example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
</head>
<body>
    <script>      
        let currentNode = 0
        let opponentNode = 0

        let boardMarginScale = 0.1
        let boardTop = boardMarginScale * window.innerHeight;
        let boardLeft = boardMarginScale * window.innerWidth;
        let boardBottom = (1 - boardMarginScale) * window.innerHeight;
        let boardRight = (1 - boardMarginScale) * window.innerWidth;

        let boardWidth = boardRight - boardLeft;
        let boardHeight = boardBottom - boardTop;

        let graphMargin = boardMarginScale * window.innerHeight
        let graphTop = boardTop + graphMargin;
        let graphLeft = boardLeft + graphMargin;
        let graphBottom = boardBottom - graphMargin;
        let graphRight = boardRight - graphMargin;

        let graphWidth = graphRight - graphLeft;
        let graphHeight = graphBottom - graphTop;

        let team;
        let graphColors;

        const WHITE = [255, 255, 255]
        const BLACK = [0, 0, 0]

        let graph = [];
        let edges = null;
        let nodesX = null;
        let nodesY = null;
        
        let numNodes;
        let nodes = [];
        let nodeColor = [0, 0, 0];
        let nodeHoverColor = [128, 128, 128]; // Color when hovered (green)
        let nodeDiameter = 50;

        let whitePosition;
        let blackPosition;

        
        const socket = io('http://localhost:8000', { path: '/socket.io/' });
        // const socket = io('http://localhost:8000/socket.io');
        
        socket.on('connect', () => {
            const socketId = sessionStorage.getItem('socketId');
            if (socketId) {
                socket.emit('reconnect', { socketId: socketId });
            } else {
                socket.emit('reconnect', { socketId: socket.id });
                sessionStorage.setItem('socketId', socket.id);
            }
        })

        socket.on('disconnect', () => {
            console.log('disconnected')
        })

        socket.on('gameData', data => {
            console.log('ENTERERERERERD')
            team = data["team"]
            graphColors = data["colors"]
            edges = data["edges"];

            positions = Object.values(data["positions"])
            whiteIdx = data["white-position"]
            blackIdx = data["black-position"]    
        
            nodesX = positions.map(position => position[0]);
            nodesY = positions.map(position => position[1]);
            fitGraph();
            for (let i = 0; i < graphColors.length; i++) {
                if (graphColors[i] === "white") {
                    nodes.push({ x: nodesX[i], y: nodesY[i], diameter: nodeDiameter, color: WHITE, hoverColor: nodeHoverColor, isClicked: false });
                } else {
                    nodes.push({ x: nodesX[i], y: nodesY[i], diameter: nodeDiameter, color: BLACK, hoverColor: nodeHoverColor, isClicked: false });
                }

            }
            
            numNodes = nodes.length

            graph = new Array(numNodes);

            for (let i = 0; i < numNodes; i++) {
                graph[i] = new Set([])
            }

            for (const edge of edges) {
                nodeA = edge[0]
                nodeB = edge[1]
                graph[nodeA].add(nodeB)
                graph[nodeB].add(nodeA)
            }

        })

        function fitGraph() {
            let minX = Math.min(...nodesX);
            let maxX = Math.max(...nodesX);
            let minY = Math.min(...nodesY);
            let maxY = Math.max(...nodesY);
            let width = maxX - minX;
            let height = maxY - minY;
            let scaleX = graphWidth / width;
            let scaleY = graphHeight / height;
            nodesX = nodesX.map(element => scaleX * (element - minX) + graphLeft);
            nodesY = nodesY.map(element => scaleY * (element - minY) + graphTop);
        }

        function trianglePositions(centerX, centerY) {
            const radius = nodeDiameter / 2;

            const topX = centerX
            const topY = centerY - nodeDiameter

            const leftX = centerX - Math.sqrt(3) * radius
            const leftY = centerY + radius

            const rightX = centerX + Math.sqrt(3) * radius
            const rightY = centerY + radius

            return [topX, topY, leftX, leftY, rightX, rightY]
        }

        // Your P5.js code goes here
        function setup() {
            createCanvas(window.innerWidth, window.innerHeight);
        }

        let count = 0;
        function draw() {
            
            if (nodes.length == 0 || edges.length == 0) {
                return
            }
            // resizeCanvas(window.innerWidth, viewHeight);
            background(255, 255, 255); // RGB values for brown
            
            fill(222, 184, 135);
            rect(boardLeft, boardTop, (1 - 2 * boardMarginScale) * window.innerWidth, (1 - 2 * boardMarginScale) * window.innerHeight);

            for (const edge of edges) {
                ni = edge[0]
                nj = edge[1]
                line(nodes[ni].x, nodes[ni].y, nodes[nj].x, nodes[nj].y)
            }

            for (let i = 0; i < nodes.length; i++) {
                let node = nodes[i]
                fill(node.color); // Red otherwise
                ellipse(node.x, node.y, node.diameter, node.diameter); // Draw the button
            }    

            let adjacents;

            if (team === 'white') {
                adjacents = graph[whiteIdx]
            } else {
                adjacents = graph[blackIdx]
            }

            for (let idx of adjacents) {
                let node = nodes[idx]
                let distance = dist(mouseX, mouseY, node.x, node.y);
                let isHovered = distance < node.diameter / 2;
                if (node.isClicked) {
                    fill(node.hoverColor);
                }
                else if (mouseIsPressed && isHovered) {
                    node.isClicked = true;
                    fill(node.hoverColor);
                    count++;

                    socket.emit('click', {})
                }
                else if (isHovered) {
                    fill(node.hoverColor); // Green if hovered
                } 
                else {
                    fill(node.color); // Red otherwise
                }
                ellipse(node.x, node.y, node.diameter, node.diameter); // Draw the button
            }    
            
            whiteCenterX = nodesX[whiteIdx]
            whiteCenterY = nodesY[whiteIdx]

            const [wX1, wY1, wX2, wY2, wX3, wY3] = trianglePositions(whiteCenterX, whiteCenterY)
            fill(WHITE)
            triangle(wX1, wY1, wX2, wY2, wX3, wY3)

            blackCenterX = nodesX[blackIdx]
            blackCenterY = nodesY[blackIdx]
            let [bX1, bY1, bX2, bY2, bX3, bY3] = trianglePositions(blackCenterX, blackCenterY)
            fill(BLACK)
            triangle(bX1, bY1, bX2, bY2, bX3, bY3)


        }


        function endGameHandler() {
            const socketId = sessionStorage.getItem('socketId');
            socket.emit('endGame', { socketId: socketId }); 
            nodes = [];
            nodesX = null;
            nodesY = null;
            edges = null
        }

        // sendData()

        // function sendData() {
        //     // const data = { newNode: currentNode };
        //     const data = { num: 0 };
        //     console.log('REACHED 0')
        //     socket.emit('updateToServer', data);
        //     console.log('REACHED 1')
        // }

        // socket.on('updateGame', (data) => {
            
        //     console.log(data)
        //     redraw(); // Request to redraw the canvas
        // });

        // function windowResized() {
        //     resizeCanvas(viewWidth, viewWidth);
        //     fitGraph()
        //     for (let i = 0; i < nodes.length; i++) {
        //         nodes[i].x = nodesX[i];
        //         nodes[i].y = nodesY[i];
        //     }
        // }




        // function setupGame() {
        //     return fetch('http://localhost:8000/play/', {
        //             method: 'GET'
        //         })
        //         .then(response => {
        //             response.json();
        //         })
        //         .then(data => {
        //             // Access node positions
        //             edges = data["edges"];
        //             // console.log(edges)
        //             positions = Object.values(data["positions"])
        //             nodesX = positions.map(position => position[0]);
        //             nodesY = positions.map(position => position[1]);
        //             fitGraph();
        //             for (let i = 0; i < edges.length; i++) {
        //                 nodes.push({ x: nodesX[i], y: nodesY[i], diameter: nodeDiameter, color: nodeColor, hoverColor: nodeHoverColor, isClicked: false });
        //             }
        //         })
        //         .catch(error => console.error('Error:', error));
        // }
    </script>
    <button onclick="endGameHandler()">End Game</button>
</body>
</html>





